<!DOCTYPE html>
<html lang="zh-Hans">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,minimum-scale=1,maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="description" content="Linux-shell脚本编程-更多结构化命令（三）"/>




  <meta name="keywords" content="linux,shell," />





  <link rel="alternate" href="/default" title="Time is the only currency" >




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.1" />



<link rel="canonical" href="http://example.com/2022/05/04/Linux-shell脚本编程-更多结构化命令（三）/"/>


<meta name="description" content="一、for命令for命令的基本格式 1234for var in listdo   commandsdone  在list参数中，你需要提供迭代中要用到的一系列值。可以通过几种不同的方法指定列表中的值。 在每次迭代中，变量var会包含列表中的当前值。第一次迭代会使用列表中的第一个值，第二次迭代使用第二个，以此类推，直到列表中的所有值都过一遍。 在do和done语句之间输入的命令可以是一条或多条标准">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux-shell脚本编程-更多结构化命令（三）">
<meta property="og:url" content="http://example.com/2022/05/04/Linux-shell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B-%E6%9B%B4%E5%A4%9A%E7%BB%93%E6%9E%84%E5%8C%96%E5%91%BD%E4%BB%A4%EF%BC%88%E4%B8%89%EF%BC%89/index.html">
<meta property="og:site_name" content="Time is the only currency">
<meta property="og:description" content="一、for命令for命令的基本格式 1234for var in listdo   commandsdone  在list参数中，你需要提供迭代中要用到的一系列值。可以通过几种不同的方法指定列表中的值。 在每次迭代中，变量var会包含列表中的当前值。第一次迭代会使用列表中的第一个值，第二次迭代使用第二个，以此类推，直到列表中的所有值都过一遍。 在do和done语句之间输入的命令可以是一条或多条标准">
<meta property="og:locale">
<meta property="og:image" content="https://raw.githubusercontent.com/calm-always/picture/main/img/image-20220504142314362.png">
<meta property="og:image" content="https://raw.githubusercontent.com/calm-always/picture/main/img/image-20220504142907808.png">
<meta property="og:image" content="https://raw.githubusercontent.com/calm-always/picture/main/img/image-20220504143434661.png">
<meta property="og:image" content="https://raw.githubusercontent.com/calm-always/picture/main/img/image-20220504144002957.png">
<meta property="og:image" content="https://raw.githubusercontent.com/calm-always/picture/main/img/image-20220504144328550.png">
<meta property="og:image" content="https://raw.githubusercontent.com/calm-always/picture/main/img/image-20220504144601980.png">
<meta property="og:image" content="https://raw.githubusercontent.com/calm-always/picture/main/img/image-20220504151051789.png">
<meta property="og:image" content="https://raw.githubusercontent.com/calm-always/picture/main/img/image-20220504201346333.png">
<meta property="og:image" content="https://raw.githubusercontent.com/calm-always/picture/main/img/image-20220504210558186.png">
<meta property="og:image" content="https://raw.githubusercontent.com/calm-always/picture/main/img/image-20220504210856594.png">
<meta property="og:image" content="https://raw.githubusercontent.com/calm-always/picture/main/img/image-20220504214756422.png">
<meta property="og:image" content="https://raw.githubusercontent.com/calm-always/picture/main/img/image-20220504215745643.png">
<meta property="og:image" content="https://raw.githubusercontent.com/calm-always/picture/main/img/image-20220504222415263.png">
<meta property="og:image" content="https://raw.githubusercontent.com/calm-always/picture/main/img/image-20220504222729684.png">
<meta property="og:image" content="https://raw.githubusercontent.com/calm-always/picture/main/img/image-20220505234812752.png">
<meta property="og:image" content="https://raw.githubusercontent.com/calm-always/picture/main/img/image-20220505235243851.png">
<meta property="og:image" content="https://raw.githubusercontent.com/calm-always/picture/main/img/image-20220505235913963.png">
<meta property="og:image" content="https://raw.githubusercontent.com/calm-always/picture/main/img/image-20220506000122679.png">
<meta property="og:image" content="https://raw.githubusercontent.com/calm-always/picture/main/img/image-20220508103329794.png">
<meta property="og:image" content="https://raw.githubusercontent.com/calm-always/picture/main/img/image-20220508103703918.png">
<meta property="og:image" content="https://raw.githubusercontent.com/calm-always/picture/main/img/image-20220508104752853.png">
<meta property="og:image" content="https://raw.githubusercontent.com/calm-always/picture/main/img/image-20220508105508499.png">
<meta property="og:image" content="https://raw.githubusercontent.com/calm-always/picture/main/img/image-20220508110243148.png">
<meta property="og:image" content="https://raw.githubusercontent.com/calm-always/picture/main/img/image-20220508110524809.png">
<meta property="og:image" content="https://raw.githubusercontent.com/calm-always/picture/main/img/image-20220508110851687.png">
<meta property="og:image" content="https://raw.githubusercontent.com/calm-always/picture/main/img/image-20220508111408679.png">
<meta property="og:image" content="https://raw.githubusercontent.com/calm-always/picture/main/img/image-20220508111807615.png">
<meta property="og:image" content="https://raw.githubusercontent.com/calm-always/picture/main/img/image-20220508113228175.png">
<meta property="og:image" content="https://raw.githubusercontent.com/calm-always/picture/main/img/image-20220508114339921.png">
<meta property="og:image" content="https://raw.githubusercontent.com/calm-always/picture/main/img/image-20220508115003192.png">
<meta property="og:image" content="https://raw.githubusercontent.com/calm-always/picture/main/img/image-20220508115525786.png">
<meta property="og:image" content="https://raw.githubusercontent.com/calm-always/picture/main/img/image-20220508122856344.png">
<meta property="og:image" content="https://raw.githubusercontent.com/calm-always/picture/main/img/image-20220508124708171.png">
<meta property="article:published_time" content="2022-05-04T06:03:18.000Z">
<meta property="article:modified_time" content="2022-05-08T05:01:17.289Z">
<meta property="article:author" content="zjh">
<meta property="article:tag" content="linux">
<meta property="article:tag" content="shell">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/calm-always/picture/main/img/image-20220504142314362.png">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=1.1" />
<link href='https://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet'>





<script type="text/javascript">
  var themeConfig = {
    fancybox: {
      enable: false
    },
  };
</script>




  



    <title> Linux-shell脚本编程-更多结构化命令（三） - Time is the only currency </title>
  <meta name="generator" content="Hexo 5.4.0"></head>

  <body>
    <div id="page">
      <header id="masthead"><div class="site-header-inner">
    <h1 class="site-title">
        <a href="/." class="logo">Time is the only currency</a>
    </h1>

    <nav id="nav-top">
        
            <ul id="menu-top" class="nav-top-items">
                
                    <li class="menu-item">
                        <a href="/archives">
                            
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li class="menu-item">
                        <a href="/about">
                            
                            
                                About
                            
                        </a>
                    </li>
                
            </ul>
        
  </nav>
</div>

      </header>
      <div id="content">
        
    <div id="primary">
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          Linux-shell脚本编程-更多结构化命令（三）
        
      </h1>

      <time class="post-time">
          May 04 2022
      </time>
    </header>



    
            <div class="post-content">
            <h3 id="一、for命令"><a href="#一、for命令" class="headerlink" title="一、for命令"></a>一、for命令</h3><p>for命令的基本格式</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for var in list</span><br><span class="line">do</span><br><span class="line">   commands</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>在list参数中，你需要提供迭代中要用到的一系列值。可以通过几种不同的方法指定列表中的值。</p>
<p>在每次迭代中，变量var会包含列表中的当前值。第一次迭代会使用列表中的第一个值，第二次迭代使用第二个，以此类推，直到列表中的所有值都过一遍。</p>
<p>在do和done语句之间输入的命令可以是一条或多条标准的bash shell命令。在这些命令中，$var变量包含着这次迭代对应的当前列表项中的值。</p>
<h4 id="1-读取列表中的值"><a href="#1-读取列表中的值" class="headerlink" title="1.读取列表中的值"></a>1.读取列表中的值</h4><p>for命令最基本的用法就是遍历for命令自身所定义的一些列值。</p>
<p><img src="https://raw.githubusercontent.com/calm-always/picture/main/img/image-20220504142314362.png" alt="image-20220504142314362"></p>
<p>在最后一次迭代后，$test变量的值会在shell脚本的剩余部分一直保持有效。它会一直保持最后一次迭代的值。</p>
<p><img src="https://raw.githubusercontent.com/calm-always/picture/main/img/image-20220504142907808.png" alt="image-20220504142907808"></p>
<h4 id="2-读取列表中的复杂值"><a href="#2-读取列表中的复杂值" class="headerlink" title="2.读取列表中的复杂值"></a>2.读取列表中的复杂值</h4><p>有时会遇到难处理的数据。下面是一个典型例子：</p>
<p><img src="https://raw.githubusercontent.com/calm-always/picture/main/img/image-20220504143434661.png" alt="image-20220504143434661"></p>
<p>以上，单引号会消失。有两种办法可以解决这个问题：</p>
<ul>
<li>使用转义字符（反斜线）来将单引号转义；</li>
<li>使用双引号来定义用到单引号的值。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/calm-always/picture/main/img/image-20220504144002957.png" alt="image-20220504144002957"></p>
<p>for循环假定每个值都是用空格分割的。如果有包含空格的数据值，那么就会存在问题。</p>
<p><img src="https://raw.githubusercontent.com/calm-always/picture/main/img/image-20220504144328550.png" alt="image-20220504144328550"></p>
<p>所以，如果单独的数据值中有空格，就必须用双引号把这些值圈起来。</p>
<p><img src="https://raw.githubusercontent.com/calm-always/picture/main/img/image-20220504144601980.png" alt="image-20220504144601980"></p>
<p>在某个值两边使用双引号时，shell并不会将双引号当成值的一部分，如果需要把双引号当成值，需要进行转义。</p>
<p><img src="https://raw.githubusercontent.com/calm-always/picture/main/img/image-20220504151051789.png" alt="image-20220504151051789"></p>
<h4 id="3-从变量读取列表"><a href="#3-从变量读取列表" class="headerlink" title="3.从变量读取列表"></a>3.从变量读取列表</h4><p>通常会将一系列值集中存储在一个变量中，然后遍历变量中的整个列表。</p>
<p><img src="https://raw.githubusercontent.com/calm-always/picture/main/img/image-20220504201346333.png" alt="image-20220504201346333"></p>
<h4 id="4-从命令读取值"><a href="#4-从命令读取值" class="headerlink" title="4.从命令读取值"></a>4.从命令读取值</h4><p>生成列表中所需值的另外一个途径就是使用命令的输出。可以用命令替换来执行任何能产生输出的命令，然后在for命令中使用该命令的输出。</p>
<p><img src="https://raw.githubusercontent.com/calm-always/picture/main/img/image-20220504210558186.png" alt="image-20220504210558186"></p>
<p>如果名字中有空格的州，for命令仍然会将每个单次当作单独的值。</p>
<h4 id="5-更改字段分隔符"><a href="#5-更改字段分隔符" class="headerlink" title="5.更改字段分隔符"></a>5.更改字段分隔符</h4><p>造成这个问题的原因是特殊的环境变量IFS，叫作<strong>内部字段分隔符。</strong>IFS环境变量定义了bash shell用作字段分隔符的一系列字符。默认情况下，bash shell会将下列字符当作字段分隔符：</p>
<ul>
<li>空格</li>
<li>制表符</li>
<li>换行符</li>
</ul>
<p>如果bash shell在数据中看到了这些字符中的任意一个，它就会假定这表明了列表中一个新数据字段的开始。在处理可能含有空格的数据时，这会非常麻烦。</p>
<p>要解决这个问题，可以在shell脚本中临时更改IFS环境变量的值来限制被bash shell当作字段分隔符的字符。如果要修改IFS的值，使其只能识别换行符：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IFS=$&#x27;\n&#x27;</span><br></pre></td></tr></table></figure>

<p>将这个语句加入到脚本中，告诉bash shell在数值中忽略空格和制表符。</p>
<p><img src="https://raw.githubusercontent.com/calm-always/picture/main/img/image-20220504210856594.png" alt="image-20220504210856594"></p>
<p>这样就能使用列表中含有空格的值了。</p>
<h4 id="6-用通配符读取目录"><a href="#6-用通配符读取目录" class="headerlink" title="6.用通配符读取目录"></a>6.用通配符读取目录</h4><p>可以用for命令来自动遍历目录中的文件。进行此操作时，必须在文件名或路径名中使用通配符。它会强制shell使用<strong>文件扩展匹配</strong>。文件扩展匹配是生成匹配指定通配符的文件名或路径名的过程。</p>
<p><img src="https://raw.githubusercontent.com/calm-always/picture/main/img/image-20220504214756422.png" alt="image-20220504214756422"></p>
<p>在Linux中，目录名和文件名中包含空格是合法的。要适应这种情况，应该将$file变量用双引号圈起来。如果不这么做，遇到含有空格的目录名或文件名时就会有错误产生。</p>
<p>也可以在for命令中列出多个目录通配符，将目录查找和列表合并进同一个for语句。</p>
<p><img src="https://raw.githubusercontent.com/calm-always/picture/main/img/image-20220504215745643.png" alt="image-20220504215745643"></p>
<h3 id="二、C语言风格的for命令"><a href="#二、C语言风格的for命令" class="headerlink" title="二、C语言风格的for命令"></a>二、C语言风格的for命令</h3><h4 id="1-C语言的for命令"><a href="#1-C语言的for命令" class="headerlink" title="1.C语言的for命令"></a>1.C语言的for命令</h4><p>C语言的for命令有一个用来指明变量的特定方法，一个必须保持成立才能继续迭代的条件，以及另一个在每个迭代中改变变量的方法。当指定的条件不成立时，for循环就会停止。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The next number is %d\n&quot;</span>, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>bash shell也支持一种for循环，它看起来和C语言风格的for循环类似，但有一些细微的不同。基本格式</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for (( variable assignment ; condition ; iteration process ))</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for (( a = 1; a &lt; 10; a++))</span><br></pre></td></tr></table></figure>

<p>C语言风格的for命令有些部分并没有遵循bash shell标准的for命令：</p>
<ul>
<li>变量赋值可以有空格</li>
<li>条件中的变量不以美元符开头</li>
<li>迭代过程的算式未用expr命令格式</li>
</ul>
<p><img src="https://raw.githubusercontent.com/calm-always/picture/main/img/image-20220504222415263.png" alt="image-20220504222415263"></p>
<h4 id="2-使用多个变量"><a href="#2-使用多个变量" class="headerlink" title="2.使用多个变量"></a>2.使用多个变量</h4><p>C语言风格的for命令也允许为迭代使用多个变量。循环会单独处理每个变量。</p>
<p><img src="https://raw.githubusercontent.com/calm-always/picture/main/img/image-20220504222729684.png" alt="image-20220504222729684"></p>
<h3 id="三、while命令"><a href="#三、while命令" class="headerlink" title="三、while命令"></a>三、while命令</h3><p>while命令某种意义上是if-then语句和for循环的混杂体。while命令允许定义一个要测试的命令，然后循环执行一组命令，只要定义的测试命令返回的是退出状态码0.它会在每次迭代的一开始测试test命令。在test命令返回非零退出状态码时，while命令会停止执行那组命令。</p>
<h4 id="1-while的基本格式"><a href="#1-while的基本格式" class="headerlink" title="1.while的基本格式"></a>1.while的基本格式</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while test command</span><br><span class="line">do</span><br><span class="line">  other commands</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/calm-always/picture/main/img/image-20220505234812752.png" alt="image-20220505234812752"></p>
<h4 id="2-使用多个测试命令"><a href="#2-使用多个测试命令" class="headerlink" title="2.使用多个测试命令"></a>2.使用多个测试命令</h4><p>while命令允许定义多个测试命令，每个测试命令都出现在单独的一行上。只有最后一个测试命令的退出状态码会被用来决定什么时候结束循环。</p>
<p><img src="https://raw.githubusercontent.com/calm-always/picture/main/img/image-20220505235243851.png" alt="image-20220505235243851"></p>
<h3 id="四、until命令"><a href="#四、until命令" class="headerlink" title="四、until命令"></a>四、until命令</h3><p>until命令和while命令工作的方式完全相反。until命令要求你指定一个通常返回非零退出状态码的测试命令。只有测试命令的退出状态码不为0，bash shell才会执行循环中列出的命令。一旦测试命令返回了退出状态码0，循环结束。命令格式如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">until test commands</span><br><span class="line">do</span><br><span class="line">  other commands</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>和while命令类似，until命令语句也可以放入多个测试命令。只有最后一个命令的退出状态码决定了bash shell是否执行已定义的other commands.</p>
<p><img src="https://raw.githubusercontent.com/calm-always/picture/main/img/image-20220505235913963.png" alt="image-20220505235913963"></p>
<p>使用多个测试命令：</p>
<p><img src="https://raw.githubusercontent.com/calm-always/picture/main/img/image-20220506000122679.png" alt="image-20220506000122679"></p>
<h3 id="五、嵌套循环"><a href="#五、嵌套循环" class="headerlink" title="五、嵌套循环"></a>五、嵌套循环</h3><p>循环语句可以在循环内使用任意类型的命令，包括其他循环命令，这种循环叫作嵌套循环。</p>
<p><img src="https://raw.githubusercontent.com/calm-always/picture/main/img/image-20220508103329794.png" alt="image-20220508103329794"></p>
<p>while循环内部放置一个for循环</p>
<p><img src="https://raw.githubusercontent.com/calm-always/picture/main/img/image-20220508103703918.png" alt="image-20220508103703918"></p>
<p>until和while混用</p>
<p><img src="https://raw.githubusercontent.com/calm-always/picture/main/img/image-20220508104752853.png" alt="image-20220508104752853"></p>
<h3 id="六、循环处理文件数据"><a href="#六、循环处理文件数据" class="headerlink" title="六、循环处理文件数据"></a>六、循环处理文件数据</h3><p>有时遍历存储在文件中的数据，需要用到两种技术：</p>
<ul>
<li>使用嵌套循环</li>
<li>修改IFS环境变量</li>
</ul>
<p>通过修改IFS环境变量，就能强制for命令将文件中的每行都当成单独的一个条目来处理，即便数据中有空格也是如此。</p>
<p>例如处理/etc/passwd文件中的数据。需要逐行遍历/etc/passwd文件，并将IFS变量的值改成冒号，这样就能分隔开每行中的各个数据段了。</p>
<p><img src="https://raw.githubusercontent.com/calm-always/picture/main/img/image-20220508105508499.png" alt="image-20220508105508499"></p>
<p>以上脚本使用了2个不同的IFS值来解析数据。第一个IFS值解析出/etc/passwd文件中的单独的行。内部for循环接着把IFS的值修改为冒号，从/etc/passwd的行中解析出单独的值。</p>
<h3 id="七、控制循环"><a href="#七、控制循环" class="headerlink" title="七、控制循环"></a>七、控制循环</h3><p>有两个命令可以控制循环：</p>
<ul>
<li>break命令</li>
<li>continue命令</li>
</ul>
<h4 id="1-break命令"><a href="#1-break命令" class="headerlink" title="1.break命令"></a>1.break命令</h4><h5 id="1-1跳出单个循环"><a href="#1-1跳出单个循环" class="headerlink" title="1.1跳出单个循环"></a>1.1跳出单个循环</h5><p><img src="https://raw.githubusercontent.com/calm-always/picture/main/img/image-20220508110243148.png" alt="image-20220508110243148"></p>
<p><img src="https://raw.githubusercontent.com/calm-always/picture/main/img/image-20220508110524809.png" alt="image-20220508110524809"></p>
<h5 id="1-2跳出内部循环"><a href="#1-2跳出内部循环" class="headerlink" title="1.2跳出内部循环"></a>1.2跳出内部循环</h5><p>在处理多个循环时，break命令会自动终止你所在的最内层的循环。</p>
<p><img src="https://raw.githubusercontent.com/calm-always/picture/main/img/image-20220508110851687.png" alt="image-20220508110851687"></p>
<h5 id="1-3跳出外部循环"><a href="#1-3跳出外部循环" class="headerlink" title="1.3跳出外部循环"></a>1.3跳出外部循环</h5><p>有时需要在内部循环中停止外部循环。break命令接受单个命令行参数值：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">break n</span><br></pre></td></tr></table></figure>

<p>n指定了要跳出的循环层级。默认情况下，n为1，表明跳出的是当前循环。如果设置为2，break命令就会停止下一级的外部循环。</p>
<p><img src="https://raw.githubusercontent.com/calm-always/picture/main/img/image-20220508111408679.png" alt="image-20220508111408679"></p>
<h4 id="2-continue命令"><a href="#2-continue命令" class="headerlink" title="2.continue命令"></a>2.continue命令</h4><p>continue可以提前终止某次循环中的命令，但不会完全终止整个循环。</p>
<p><img src="https://raw.githubusercontent.com/calm-always/picture/main/img/image-20220508111807615.png" alt="image-20220508111807615"></p>
<p>可以在while和until循环中使用continue命令，但是，当shell执行continue命令时，它会跳过剩余的命令。如果在其中某个条件里对测试条件变量进行增值，就会出现问题。</p>
<p><img src="https://raw.githubusercontent.com/calm-always/picture/main/img/image-20220508113228175.png" alt="image-20220508113228175"></p>
<p>以上例子，触发continue命令之后，var1的值不会再变化，因此陷入死循环。</p>
<p>和break命令一样，continue命令也允许通过命令行参数指定要继续执行哪一级循环：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">continue n</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/calm-always/picture/main/img/image-20220508114339921.png" alt="image-20220508114339921"></p>
<h3 id="八、处理循环的输出"><a href="#八、处理循环的输出" class="headerlink" title="八、处理循环的输出"></a>八、处理循环的输出</h3><p>在shell脚本中，你可以对循环的输出使用管道或进行重定向。可以通过在done命令之后添加一个处理命令来实现：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for file in /home/rich/*</span><br><span class="line">do</span><br><span class="line">  if [ -d &quot;$file&quot; ]</span><br><span class="line">  then</span><br><span class="line">      echo &quot;$file is a directory&quot;</span><br><span class="line">  elif</span><br><span class="line">      echo &quot;$file is a file&quot;</span><br><span class="line">  fi</span><br><span class="line">done &gt; output.txt</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/calm-always/picture/main/img/image-20220508115003192.png" alt="image-20220508115003192"></p>
<p>也可以将循环的结果管接给另一个命令：</p>
<p><img src="https://raw.githubusercontent.com/calm-always/picture/main/img/image-20220508115525786.png" alt="image-20220508115525786"></p>
<h3 id="九、实例"><a href="#九、实例" class="headerlink" title="九、实例"></a>九、实例</h3><h4 id="1-查找可执行文件"><a href="#1-查找可执行文件" class="headerlink" title="1.查找可执行文件"></a>1.查找可执行文件</h4><p><img src="https://raw.githubusercontent.com/calm-always/picture/main/img/image-20220508122856344.png" alt="image-20220508122856344"></p>
<h4 id="2-创建多个用户账户"><a href="#2-创建多个用户账户" class="headerlink" title="2.创建多个用户账户"></a>2.创建多个用户账户</h4><p>批量创建用户</p>
<p>把需要添加的新用户账户放在一个文本文件中，然后创建一个简单的脚本进行处理。文本文件的格式如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userid,username</span><br></pre></td></tr></table></figure>

<p>第一个条目是为新用户账户选用的用户ID，第二个条目是用户的全名。两个值之间使用逗号分隔，这样就形成了一种名为逗号分隔值的文件格式。</p>
<p><img src="https://raw.githubusercontent.com/calm-always/picture/main/img/image-20220508124708171.png" alt="image-20220508124708171"></p>
<h3 id="十、总结"><a href="#十、总结" class="headerlink" title="十、总结"></a>十、总结</h3><p>for命令允许你遍历一系列的值，包括在命令行提供好的，包含在变量中的、通过文件扩展匹配获得的文件名和目录名。</p>
<p>while命令使用普通命令或测试命令提供了基本命令条件的循环。在命令（或条件）产生退出状态码0时，while循环才会继续迭代指定的一组命令。</p>
<p>until命令也提供了迭代命令的一种方法，但它的迭代是建立在命令（或条件）产生非零退出状态码的基础上。这个特性允许我们设置一个迭代结束前都必须满足的条件。</p>
<p>shell提供了continue和break命令，来改变循环的流程。</p>
<p>bash shell还允许使用标准的命令重定向和管道来改变循环的输出。可以将循环的输出重定向到一个文件或命令。</p>

            </div>
          

    
      <footer class="post-footer">
		
		<div class="post-tags">
		  
			<a href="/tags/linux/">linux</a>
		  
			<a href="/tags/shell/">shell</a>
		  
		</div>
		

        
        
  <nav class="post-nav">
    
    
      <a class="next" href="/2022/05/02/Linux-shell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B-%E4%BD%BF%E7%94%A8%E7%BB%93%E6%9E%84%E5%8C%96%E5%91%BD%E4%BB%A4%EF%BC%88%E4%BA%8C%EF%BC%89/">
        <span class="next-text nav-default">Linux-shell脚本编程-使用结构化命令（二）</span>
        <span class="prev-text nav-mobile">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

        
  <div class="comments" id="comments">
    
  </div>


      </footer>
    
  </article>

    </div>

      </div>

      <footer id="colophon"><span class="copyright-year">
    
        &copy;
    
        2014 -
    
    2022
    <span class="footer-author">zjh.</span>
    <span class="power-by">
        Powered by <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> and <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/frostfan/hexo-theme-polarbear">Polar Bear</a>
    </span>
</span>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>
    


    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  

    <script type="text/javascript" src="/js/src/theme.js?v=1.1"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=1.1"></script>

  </body>
</html>
